name: Workers Ai Catalog

on:
  push:
    paths:
      - '.github/workflows/workers-ai-catalog.yml'
      - 'packages/types/src/ai-tools/workers-ai/catalog.ts'
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  workersAi:
    runs-on: ubuntu-latest
    if: github.actor != 'sushidata-cloudflare[bot]'
    permissions:
      contents: write
    env:
      CATALOG_FILES: '["packages/types/src/ai-tools/workers-ai/catalog.ts"]'
    steps:
      - uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          disable-sudo-and-containers: true
          egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs
      - uses: actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e # v2.0.6
        id: gh_cloudflare_token
        with:
          app-id: ${{ vars.GH_CLOUDFLARE_CLIENT_ID }}
          private-key: ${{ secrets.GH_CLOUDFLARE_PRIVATE_KEY }}
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          token: ${{ steps.gh_cloudflare_token.outputs.token }}
      - uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          CATALOG_FILES: ${{ env.CATALOG_FILES }}
        with:
          script: |
            const catalogFiles = JSON.parse(process.env.CATALOG_FILES);
            const catalogFile = catalogFiles[0]; // Use the first file in the array
            
            await Promise.all([
                fetch(new URL(`client/v4/accounts/${process.env.CF_ACCOUNT_ID}/ai/models/search`, 'https://api.cloudflare.com'), {
                    headers: {
                        Authorization: `Bearer ${process.env.CICD_CF_API_TOKEN}`,
                    },
                }).then((modelResponse) => {
                    if (modelResponse.ok) {
                        return modelResponse.json();
                    } else {
                        throw new Error(modelResponse.statusText, { cause: modelResponse.status });
                    }
                }),
                fetch(new URL(`client/v4/accounts/${process.env.CF_ACCOUNT_ID}/ai/finetunes`, 'https://api.cloudflare.com'), {
                    headers: {
                        Authorization: `Bearer ${process.env.CICD_CF_API_TOKEN}`,
                    },
                }).then((privateLoraResult) => {
                    if (privateLoraResult.ok) {
                        return privateLoraResult.json();
                    } else {
                        throw new Error(privateLoraResult.statusText, { cause: privateLoraResult.status });
                    }
                }),
                fetch(new URL(`client/v4/accounts/${process.env.CF_ACCOUNT_ID}/ai/finetunes/public`, 'https://api.cloudflare.com'), {
                    headers: {
                        Authorization: `Bearer ${process.env.CICD_CF_API_TOKEN}`,
                    },
                }).then((publicLoraResult) => {
                    if (publicLoraResult.ok) {
                        return publicLoraResult.json();
                    } else {
                        throw new Error(publicLoraResult.statusText, { cause: publicLoraResult.status });
                    }
                }),
            ]).then(async ([{ result: modelJson }, { result: privateLoraJson }, { result: publicLoraJson }]) => {
                const grouped = {};

                modelJson.forEach((model) => {
                    // Pull out model group into a upper level key
                    const taskName = model.task.name;
                    if (!grouped[taskName]) {
                        grouped[taskName] = {
                            id: model.task.id,
                            description: model.task.description,
                            models: [],
                        };
                    }

                    const { task, ...modelWithoutTask } = model;

                    // Convert stringified values to primitives, if possible
                    const properties = model.properties.reduce((acc, prop) => {
                        let value = prop.value;
                        if (['true', 'false', '0', '1', 0, 1].includes(value)) {
                            value = Boolean(value);
                        } else if (!isNaN(value)) {
                            value = Number(value);
                        }
                        acc[prop.property_id] = value;
                        return acc;
                    }, {});

                    grouped[taskName].models.push({ ...modelWithoutTask, properties });
                });

                await import('node:fs').then(({ createWriteStream }) => {
                    const writeStream = createWriteStream(catalogFile, { encoding: 'utf8' });
                    writeStream.write(
                        `export const workersAiCatalog = ${JSON.stringify(
                            {
                                modelGroups: grouped,
                                loras: [...privateLoraJson, ...publicLoraJson].map((lora) => ({
                                    // The api endpoint doesn't provide `public` on the private endpoint
                                    public: false,
                                    // Convert stringified values to primitives, if possible
                                    ...Object.entries(lora).reduce((acc, prop) => {
                                        console.log('prop', prop);
                                        let value = prop[1];
                                        if (['true', 'false', '0', '1', 0, 1].includes(value)) {
                                            value = Boolean(value);
                                        } else if (!isNaN(value)) {
                                            value = Number(value);
                                        }
                                        acc[prop[0]] = value;
                                        return acc;
                                    }, {}),
                                })),
                            },
                            null,
                            '\t',
                        )} as const`,
                    );
                    writeStream.end();
                });
            });
        env:
          CICD_CF_API_TOKEN: ${{ secrets.CICD_CF_API_TOKEN }}
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: lts/*
          check-latest: true
          cache: 'npm'
      - run: npm ci --include-workspace-root
      - run: |
          # Parse catalog files from environment variable and format them
          echo '${{ env.CATALOG_FILES }}' | jq -r '.[]' | while read file; do
            npx prettier --write "$file"
          done
      - name: Commit and Push Changes
        env:
          GH_TOKEN: ${{ steps.gh_cloudflare_token.outputs.token }}
        run: |
          # Parse catalog files from environment variable
          CATALOG_FILES=($(echo '${{ env.CATALOG_FILES }}' | jq -r '.[]'))
          
          # Check if any of the catalog files have changes
          HAS_CHANGES=false
          for file in "${CATALOG_FILES[@]}"; do
            if ! git diff --quiet "$file"; then
              HAS_CHANGES=true
              break
            fi
          done
          
          if [ "$HAS_CHANGES" = true ]; then
            # Add the files to staging
            for file in "${CATALOG_FILES[@]}"; do
              if ! git diff --quiet "$file"; then
                git add "$file"
              fi
            done
            
            # Get the current branch and repository info
            BRANCH_NAME="${{ github.ref_name }}"
            REPO_OWNER="${{ github.repository_owner }}"
            REPO_NAME="${{ github.event.repository.name }}"
            
            # Get current commit SHA
            CURRENT_SHA=$(git rev-parse HEAD)
            
            # Create blob objects and tree entries for changed files
            declare -a TREE_ENTRIES
            for file in "${CATALOG_FILES[@]}"; do
              if ! git diff --quiet HEAD "$file"; then
                # Create blob for the changed file
                BLOB_SHA=$(gh api "repos/$REPO_OWNER/$REPO_NAME/git/blobs" \
                  --method POST \
                  --field content="$(base64 -w 0 "$file")" \
                  --field encoding="base64" \
                  --jq '.sha')
                
                # Add to tree entries
                TREE_ENTRIES+=("{\"path\":\"$file\",\"mode\":\"100644\",\"type\":\"blob\",\"sha\":\"$BLOB_SHA\"}")
              fi
            done
            
            # Create tree with the blobs
            TREE_JSON="[$(IFS=,; echo "${TREE_ENTRIES[*]}")]"
            TREE_SHA=$(gh api "repos/$REPO_OWNER/$REPO_NAME/git/trees" \
              --method POST \
              --field base_tree="$CURRENT_SHA" \
              --raw-field tree="$TREE_JSON" \
              --jq '.sha')
            
            # Create commit
            COMMIT_SHA=$(gh api "repos/$REPO_OWNER/$REPO_NAME/git/commits" \
              --method POST \
              --field message="Updated workers-ai model catalog" \
              --field tree="$TREE_SHA" \
              --raw-field parents="[\"$CURRENT_SHA\"]" \
              --field author.name="${{ steps.gh_cloudflare_token.outputs.app-slug }}[bot]" \
              --field author.email="${{ vars.GH_CLOUDFLARE_USER_ID }}+${{ steps.gh_cloudflare_token.outputs.app-slug }}[bot]@users.noreply.github.com" \
              --field committer.name="${{ steps.gh_cloudflare_token.outputs.app-slug }}[bot]" \
              --field committer.email="${{ vars.GH_CLOUDFLARE_USER_ID }}+${{ steps.gh_cloudflare_token.outputs.app-slug }}[bot]@users.noreply.github.com" \
              --jq '.sha')
            
            # Update branch reference
            gh api "repos/$REPO_OWNER/$REPO_NAME/git/refs/heads/$BRANCH_NAME" \
              --method PATCH \
              --field sha="$COMMIT_SHA"
          else
            echo "model catalog not touched"
          fi
